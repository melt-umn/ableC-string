#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <setjmp.h>
#include <signal.h>

#ifndef _STRING_XH
#define _STRING_XH

struct __attribute__((refId("edu:umn:cs:melt:exts:ableC:string:string"))) _string_s {
  size_t length;
  const char *text;
};

static const size_t MAX_POINTER_STR_LEN = sizeof(void *) * 2 + 2;
static const size_t MAX_FLOAT_STR_LEN = 20;
static const size_t MAX_DOUBLE_STR_LEN = 24;
static const size_t MAX_LONG_DOUBLE_STR_LEN = 45;

#define MAX_INT_TYPE_STR_LEN(ty) ((CHAR_BIT * sizeof(ty) - 1) / 3 + 2)
static const size_t MAX_CHAR_STR_LEN = MAX_INT_TYPE_STR_LEN(char);
static const size_t MAX_SHORT_STR_LEN = MAX_INT_TYPE_STR_LEN(short);
static const size_t MAX_INT_STR_LEN = MAX_INT_TYPE_STR_LEN(int);
static const size_t MAX_LONG_STR_LEN = MAX_INT_TYPE_STR_LEN(long);
static const size_t MAX_LONG_LONG_STR_LEN = MAX_INT_TYPE_STR_LEN(long long);

static const struct _string_s TRUE_STR = {4, "true"};
static const struct _string_s FALSE_STR = {5, "false"};

// Functions prefixed with _ are considered internal to the implementation of the extension
// Other functions are in theory OK to call directly

static inline char subscript_string(string s, size_t i) {
  if (i < 0 || i >= s.length) {
    fprintf(stderr, "String index out of bounds: length %lu, index %lu\n", s.length, i);
    abort();
  }
  return s.text[i];
}

static inline _Bool equals_string(string s1, string s2) {
  return s1.length == s2.length && !strcmp(s1.text, s2.text);
}

static inline void _check_string_bounds(string s, size_t start, size_t end) {
  if (start < 0 || start >= s.length || end < 0 || end >= s.length || start > end) {
    fprintf(stderr, "Substring index out of bounds: length %lu, start %lu, end %lu\n", s.length, start, end);
    abort();
  }
}

static inline size_t escape_char(char *buf, char c) {
  size_t bufIndex = 0;
  switch (c) {
    case '\a':
      buf[bufIndex++] = '\\';
      buf[bufIndex++] = 'a';
      break;
    case '\b':
      buf[bufIndex++] = '\\';
      buf[bufIndex++] = 'b';
      break;
    case '\n':
      buf[bufIndex++] = '\\';
      buf[bufIndex++] = 'n';
      break;
    case '\r':
      buf[bufIndex++] = '\\';
      buf[bufIndex++] = 'r';
      break;
    case '\t':
      buf[bufIndex++] = '\\';
      buf[bufIndex++] = 't';
      break;
    case '\v':
      buf[bufIndex++] = '\\';
      buf[bufIndex++] = 'v';
      break;
    case '\"':
    case '\'':
    case '\\':
  //case '\?':
      buf[bufIndex++] = '\\';
      buf[bufIndex++] = c;
      break;
    default:
      buf[bufIndex++] = c;
  }
  buf[bufIndex] = '\0';

  return bufIndex;
}

static inline size_t show_char(char *buf, char c) {
  size_t bufIndex = 0;
  buf[bufIndex++] = '\'';
  bufIndex += escape_char(buf + bufIndex, c);
  buf[bufIndex++] = '\'';
  buf[bufIndex] = '\0';

  return bufIndex;
}

static inline size_t show_string_max_len(string s) {
  return 2 * s.length + 3;  // Worst-case size, if all chars are escaped
}

static inline size_t show_string(char *buf, string s) {
  buf[0] = '\"';
  size_t bufIndex = 1;
  for (size_t i = 0; i < s.length; i++) {
    bufIndex += escape_char(buf + bufIndex, s.text[i]);
  }
  buf[bufIndex++] = '\"';
  buf[bufIndex] = '\0';
  return bufIndex;
}

// Hacky way of testing if a pointer can be dereferenced validly
// TODO: This isn't remotely thread safe, but I don't know of a better way
static jmp_buf _segv_jmp_buf;
static void _handle_sig(int sig) {
  longjmp(_segv_jmp_buf, 1);
}

static struct sigaction _old_segv, _old_bus;
static inline void _set_handler() {
  struct sigaction sa;
  sa.sa_handler = _handle_sig;
  sa.sa_flags |= SA_NODEFER;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGSEGV, &sa, &_old_segv)) {
    perror("Couldn't set dereference SIGSEGV handler");
    abort();
  }
  if (sigaction(SIGBUS, &sa, &_old_bus)) {
    perror("Couldn't set dereference SIGBUS handler");
    abort();
  }
}
static inline void _clear_handler() {
  if (sigaction(SIGSEGV, &_old_segv, NULL)) {
    perror("Couldn't reset dereference SIGSEGV handler");
    abort();
  }
  if (sigaction(SIGBUS, &_old_bus, NULL)) {
    perror("Couldn't reset dereference SIGBUS handler");
    abort();
  }
}

static void *safe_memcpy(void *dest, const void *src, size_t n) {
  void *res = NULL;
  if (src) {
    _set_handler();
    if (!setjmp(_segv_jmp_buf)) {
      res = memcpy(dest, src, n);
    }
    _clear_handler();
  }
  return res;
}

static size_t safe_strlen(const char *s) {
  size_t len = -1;
  if (s) {
    _set_handler();
    if (!setjmp(_segv_jmp_buf)) {
      len = strlen(s);
    }
    _clear_handler();
  }
  return len;
}

static inline size_t show_char_pointer_max_len(char *s) {
  size_t len = safe_strlen(s);

  if (len != -1) {
    return 2 * strlen(s) + 1;
  } else {
    return 35;
  }
}

static inline size_t show_char_pointer(char *buf, char *s) {
  size_t len = safe_strlen(s);
  
  if (len != -1) {
    return show_string(buf, (string)(struct _string_s){len, s});
  } else {
    return sprintf(buf, "<char * at %p>", (void*)s);
  }
}

#endif
